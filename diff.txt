diff --git a/.gitignore b/.gitignore
index 2e07832..0298769 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,6 @@
 .pio/
 .vscode/
-acervo/
+.acervo/
 desktop.ini
 alias.txt
 docs/flows/workdflow.md
\ No newline at end of file
diff --git a/README.md b/README.md
index f11d445..2404671 100644
--- a/README.md
+++ b/README.md
@@ -31,7 +31,7 @@ The DTMF System Control project focuses on utilizing DTMF (Dual-Tone Multi-Frequ
 
 ## Workflow
 
-Here you can place the description, instructions, or any relevant information about the workflow of your project. This might include an explanation of how the DTMF modules are integrated with the Arduino, how to set up and configure the system, testing procedures, etc.
+relevant information about the workflow of your project. This might include an explanation of how the DTMF modules are integrated with the Arduino, how to set up and configure the system, testing procedures, etc.
 
 ## Features
 
diff --git a/docs/main.cpp b/docs/main.cpp
deleted file mode 100644
index 05f38b5..0000000
--- a/docs/main.cpp
+++ /dev/null
@@ -1,135 +0,0 @@
-// ============== LIBRARIES ========================
-#include <Arduino.h>
-#include <avr/io.h>
-#include <util/delay.h>
-
-// ============== DEFINIÇÃO CONSTANTE ============
-#define BAUD 9600
-#define MYUBRR F_CPU / 16 / BAUD - 1
-#define MAX_SEQUENCE_LENGTH 20
-
-// ============== VARIAVEIS GLOBAL ===================
-uint8_t read[MAX_SEQUENCE_LENGTH]; // Array para armazenar a sequência de tons
-uint8_t sequence_length = 0;       // Variável para rastrear o comprimento atual da sequência
-uint8_t number;                    // Variável para armazenar o número do tom recebido
-uint8_t keyword = 0;               // Variável para determinar qual senha foi correspondida
-
-// -------------- PASSWORDS ---------------------------
-uint8_t password1[] = {0x00, 0x00, 0x00}; // Primeira senha
-uint8_t password2[] = {0, 0, 0};          // Segunda senha
-uint8_t password3[] = {2, 2, 3};          // Terceira senha
-
-// ============= DECLARAÇÃO PROTOTIPOS ===============
-void USART_Init(unsigned int ubrr);      // Inicializa a comunicação serial
-void USART_Transmit(unsigned char data); // Transmite dados via comunicação serial
-void USART_Println(const char *s);       // Imprime uma string seguida de nova linha
-bool check_password(uint8_t *password);  // Verifica se a sequência de tons corresponde a uma senha
-
-// ================= MAIN ============================
-int main(void)
-{
-    USART_Init(MYUBRR); // Inicializa a comunicação serial
-
-    DDRD &= 0xF8;  // Configura os pinos D3 até D7 como entrada
-    DDRB = 0xF7;  // Para os pinos 9, 10 e 11 como saída, e o pino 8 como entrada
-    PORTB = 0x00; // Define os pinos 8, 9 e 10 em LOW
-
-    USART_Println("\nREADING TONE...");
-
-    while (1)
-    {   
-        _delay_ms(10);
-        if (PINB & (1 << PINB0)) // Verifica o estado do pino 8 (PB0)
-
-        {
-            
-            // Se o botão estiver pressionado, verifica se a sequência de tons corresponde a alguma senha
-            if (check_password(password1))
-            {
-                USART_Println("\nativando relé 1"); // Ativa o relé 1 se a senha for correspondida
-
-                PORTB |= (1 << PB1); // Define o pino 9 (PB1) como HIGH, mantendo os outros pinos inalterados
-            }
-            else if (check_password(password2))
-            {
-                USART_Println("\nativando relé 2"); // Ativa o relé 2 se a senha for correspondida
-                PORTB |= (1 << PB2);                // Define o pino 10 como HIGH, mantendo os outros pinos inalterados
-            }
-            else if (check_password(password3))
-            {
-                USART_Println("\nativando relé 3"); // Ativa o relé 3 se a senha for correspondida
-                PORTB |= (1 << PB3);                // Define o pino 11 como HIGH, mantendo os outros pinos inalterados
-            }
-            else
-            {
-                USART_Println("\nINVALID PASSWORD..."); // Imprime mensagem de senha inválida
-            }
-
-            PORTB &= ~((1 << PB1) | (1 << PB2) | (1 << PB3)); // Define os pinos 9, 10 e 11 como LOW, mantendo os outros pinos inalterados
-
-            sequence_length = 0; // Reseta a sequência
-            _delay_ms(20);      // Aguarda antes de ler uma nova sequência
-        }
-        else
-        {
-            bool signal = PIND & (1 << PIND7); // Lê o estado do pino D7
-            _delay_ms(20);
-            if (signal) // Se um sinal for detectado no pino D7
-            {
-                _delay_ms(100);              // Aguarda 100ms para evitar debouncing
-                number = (PIND & 0x78) >> 3; // Lê o número do tom dos pinos D3 a D6
-
-                if (sequence_length < MAX_SEQUENCE_LENGTH)
-                {
-                    read[sequence_length++] = number; // Adiciona o tom à sequência
-                }
-
-                USART_Transmit(number + '0'); // Imprime o número do tom recebido
-                USART_Transmit('\n');         // Imprime uma nova linha
-            }
-        } // FIM ELSE
-    } // FIM WHILE
-
-    return 0;
-} // FIM MAIN
-
-// ################# SUB ROTINAS ###########################
-
-// Função para verificar se a sequência de tons corresponde a uma senha
-bool check_password(uint8_t *password)
-{
-    for (uint8_t i = 0; i < 3; i++)
-    {
-        if (read[i] != password[i]) // Verifica cada elemento da sequência com a senha
-            return false;           // Se houver uma diferença, retorna falso
-    }
-    return true; // Se a sequência corresponder à senha, retorna verdadeiro
-}
-
-// Inicializa a comunicação serial
-void USART_Init(unsigned int ubrr)
-{
-    UBRR0H = (unsigned char)(ubrr >> 8);
-    UBRR0L = (unsigned char)ubrr;
-    UCSR0B = (1 << RXEN0) | (1 << TXEN0);
-    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
-}
-
-// Transmite um byte via comunicação serial
-void USART_Transmit(unsigned char data)
-{
-    while (!(UCSR0A & (1 << UDRE0)))
-        ;        // Aguarda o buffer de transmissão estar vazio
-    UDR0 = data; // Transmite o byte
-}
-
-// Imprime uma string seguida de nova linha via comunicação serial
-void USART_Println(const char *s)
-{
-    while (*s)
-    {
-        USART_Transmit(*s++); // Transmite cada caractere da string
-    }
-    USART_Transmit('\r'); // Transmite o caractere de retorno de carro (CR)
-    USART_Transmit('\n'); // Transmite o caractere de nova linha (LF)
-}
\ No newline at end of file
diff --git a/docs/reg_Atmega328p.md b/docs/reg_Atmega328p.md
deleted file mode 100644
index 56ad45f..0000000
--- a/docs/reg_Atmega328p.md
+++ /dev/null
@@ -1,38 +0,0 @@
-<h1 align="center"> REGISTRADORES BÁSCIOS</h1>
-
-| Registrador | Descrição | Função | Pinos (MCU) | Portas (Arduino) |
-|-------------|-----------|--------|--------------|------------------|
-| DDRB        | Data Direction Register B | Define a direção do pino como entrada/saída | D13-D8 | 13-8 |
-| DDRC        | Data Direction Register C | Define a direção do pino como entrada/saída | A5-A0 | A5-A0 |
-| DDRD        | Data Direction Register D | Define a direção do pino como entrada/saída | D7-D0 | 7-0 |
-| PORTB       | Port Output Register | Define o estado de saída do pino (HIGH/LOW) | D13-D8 | 13-8 |
-| PORTC       | Port Output Register | Define o estado de saída do pino (HIGH/LOW) | A5-A0 | A5-A0 |
-| PORTD       | Port Output Register | Define o estado de saída do pino (HIGH/LOW) | D7-D0 | 7-0 |
-| PINB        | Port Input Register | Lê o estado do pino (HIGH/LOW) | D13-D8 | 13-8 |
-| PINC        | Port Input Register | Lê o estado do pino (HIGH/LOW) | A5-A0 | A5-A0 |
-| PIND        | Port Input Register | Lê o estado do pino (HIGH/LOW) | D7-D0 | 7-0 |
-
----
-
-## EQUIVALENCIA
-
-| Hexadecimal | Decimal | Binário     |
-|-------------|---------|-------------|
-| 0           | 0       | 0000        |
-| 1           | 1       | 0001        |
-| 2           | 2       | 0010        |
-| 3           | 3       | 0011        |
-| 4           | 4       | 0100        |
-| 5           | 5       | 0101        |
-| 6           | 6       | 0110        |
-| 7           | 7       | 0111        |
-| 8           | 8       | 1000        |
-| 9           | 9       | 1001        |
-| A           | 10      | 1010        |
-| B           | 11      | 1011        |
-| C           | 12      | 1100        |
-| D           | 13      | 1101        |
-| E           | 14      | 1110        |
-| F           | 15      | 1111        |
-
----
diff --git a/src/main.cpp b/src/main.cpp
index 45f18c5..bd11576 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -26,7 +26,6 @@ void USART_Println(const char *s);       // Imprime uma string seguida de nova l
 bool check_password(uint8_t *password);  // Verifica se a sequência de tons corresponde a uma senha
 
 // ================= MAIN ============================
-
 int main(void)
 {
     USART_Init(MYUBRR); // Inicializa a comunicação serial
@@ -36,7 +35,6 @@ int main(void)
     PORTB = 0x00; // Define os pinos 8, 9 e 10 em LOW
 
     USART_Println("\nREADING TONE...");
-    USART_Println("\n=======================.");
 
     while (1)
     {   
@@ -97,7 +95,6 @@ int main(void)
     return 0;
 } // FIM MAIN
 
-
 // ################# SUB ROTINAS ###########################
 
 // Função para verificar se a sequência de tons corresponde a uma senha
@@ -137,4 +134,4 @@ void USART_Println(const char *s)
     }
     USART_Transmit('\r'); // Transmite o caractere de retorno de carro (CR)
     USART_Transmit('\n'); // Transmite o caractere de nova linha (LF)
-}
\ No newline at end of file
+}
